#version 450

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable

#define const_ambient 0.1
#define const_scale 0.75
#define const_shadow 0.25

#define MATERIAL_COUNT 16
#define SHADOW_MAP_CASCADES 4

layout (binding = 1) uniform sampler2D blendTexture;
layout (binding = 2) uniform sampler2DArray texArray;
layout (binding = 3) uniform sampler2DArray shadowMap;

struct AmbientLight// | base alignment = 16 + 16 + 16 = 64 | stride = 64
{
	vec4 direction;// direction | base alignment = 16 | offset = 0
	vec4 diffuse;// diffuse | base alignment = 16 | offset = 16
	vec4 specular;// specular | base alignment = 16 | offset = 32
	vec4 ambient;// ambient | base alignment = 16 | offset = 48
};

struct Material// | base alignment = 16 + 16 + 16 + 4 = 52 | stride = 64
{
	vec4 ambient;// ambient | base alignment = 16 | offset = 0
	vec4 diffuse;// diffuse | base alignment = 16 | offset = 16
	vec4 specular;// specular color | base alignment = 16 | offset = 32
	float shininess;// shininess | base alignment = 4 | offset = 48
};

layout (std140, set = 0, binding = 4) uniform UniformBufferObjFrag// | base alignment = 64 + 16 + 16 + 4 + 64 = 164 | stride = 176
{
	AmbientLight light;// base alignment = 64
	vec4 camPos;// base alignment = 16 | offset = 64
	vec4 skyColor;// base alignment = 16 | offset = 80
	vec4 splits;// base alignment = 4 | offset = 96
	mat4 casMVP[SHADOW_MAP_CASCADES];// base alignment = 64 | offset = 100
} ufrag;

layout (std430, set = 0, binding = 5) buffer MaterialStorage
{
	Material data[];
} materials;

// Layout inputs
layout (location = 0) in vec3 fragColor;
layout (location = 1) in vec2 fragUV;
layout (location = 2) in vec3 fragNormal;
layout (location = 3) in vec3 fragVert;
layout (location = 4) in vec3 fragView;
layout (location = 5) in float visibility;

layout (location = 0) out vec4 outPosition;
layout (location = 1) out vec4 outNormal;
layout (location = 2) out vec4 outAlbedo;

/*
const mat4 biasMat = mat4( 
	0.5, 0.0, 0.0, 0.0,
	0.0, 0.5, 0.0, 0.0,
	0.0, 0.0, 1.0, 0.0,
	0.5, 0.5, 0.0, 1.0 
);

float textureProj(vec4 p, float casIndex, vec2 off)
{
	float shadow = 1.0F;
	float bias = 0.005F;
	vec4 sC = p / p.w;
	
	if (sC.z > -1.0 && sC.z < 1.0)
	{
		float d = texture(shadowMap, vec3(sC.st + off, casIndex)).r;
		if (sC.w > 0.0 && d < sC.z - bias)
			shadow = const_shadow;
	}
	
	return shadow;
}

float filterPCF(vec4 sc, float casIndex)
{
	ivec2 texDim = textureSize(shadowMap, 0).xy;
	float dx = const_scale / texDim.x;
	float dy = const_scale / texDim.y;
	
	float sF = 0.0F;
	int count = 0;
	int range = 1;
	
	for (int x = -range; x <= range; x++)
	{
		for (int y = -range; y <= range; y++)
		{
			sF += textureProj(sc, casIndex, vec2(dx * x, dy * y));
			count++;
		}
	}
	
	return sF / count;
}
*/
void main()
{
	// Blend Mapping of Terrain
	vec4 blendMapColor = texture(blendTexture, fragUV.xy);

	//vec2 tiledCoords = fragUV.xy * 512.0;
	vec2 tiledCoords = fragUV.xy * 32;

	vec4 backTC = texture(texArray, vec3(tiledCoords.xy, 0.0)) * (1 - blendMapColor.r - blendMapColor.g - blendMapColor.b);
	vec4 rTC = texture(texArray, vec3(tiledCoords.xy, 1.0)) * blendMapColor.r;
	vec4 gTC = texture(texArray, vec3(tiledCoords.xy, 2.0)) * blendMapColor.g;
	vec4 bTC = texture(texArray, vec3(tiledCoords.xy, 3.0)) * blendMapColor.b;

	//vec4 color = (backTC + rTC + gTC + bTC);
	
	// Color Shader
	//float attenu = 1.0F;
	//int index = 0;
	//vec3 lightDir = normalize(ufrag.light.direction.xyz);
	
	//vec3 N = normalize(fragNormal);
	//float DP = dot(N, lightDir);
	
	// Shadow Mapping
	//uint casIndex = 0;
	//for (uint i = 0; i < SHADOW_MAP_CASCADES - 1; ++i)
	//{
	//	if (fragView.z < ufrag.splits[i])
	//		casIndex = i + 1;
	//}
	
	//vec4 shadowCoord = (biasMat * ufrag.casMVP[casIndex]) * vec4(fragVert, 1.0);
	//float shadow = filterPCF(shadowCoord / shadowCoord.w, casIndex);
	/* Debug *///float shadow = 1.0;
	
	/* Diffuse */
	//vec3 texMatDiff = color.rgb + materials.data[index].diffuse.rgb;
	//vec3 texMatDiff = color.rgb;
	//vec3 diffuse = attenu * ufrag.light.diffuse.rgb * texMatDiff * max(0.0, DP) * shadow;
	
	/* Ambient */
	//vec3 ambient = ufrag.light.ambient.rgb * (materials.data[index].ambient.rgb + texMatDiff);
	
	/* Specular */
	//vec3 specular;
	
	//if (materials.data[index].shininess == 0.0F || DP < 0.0)
	//{
	//	specular = vec3(0.0, 0.0, 0.0);
	//} else
	//{
	//	vec3 V = normalize(ufrag.camPos.xyz - fragVert);
	//	vec3 R = reflect(-lightDir, N);
	//	float coef = dot(R, V);
	//	
	//	specular = attenu * ufrag.light.specular.rgb * materials.data[index].specular.rgb * pow(max(0.0, coef), materials.data[index].shininess) * shadow;
	//}
	
	//vec3 lightColor = specular + diffuse + ambient;
	//vec3 finalColor = mix(ufrag.skyColor.rgb, lightColor, visibility);
	//outColor = vec4(finalColor, color.a);

	outPosition = vec4(fragVert.z, fragVert.y, fragVert.x, 1.0);
	outNormal = vec4(fragNormal.z, fragNormal.y, fragNormal.z, 1.0);
	outAlbedo = (backTC + rTC + gTC + bTC);
}