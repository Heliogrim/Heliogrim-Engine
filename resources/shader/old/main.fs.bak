#version 450

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
//#extension GL_ARB_shader_image_load_store : enable

#define const_ambient 0.1
#define const_scale 0.75
#define const_shadow 0.25

#define MATERIAL_COUNT 16
#define SHADOW_MAP_CASCADES 4

#define _texId ambient.a

//layout (early_fragment_tests) in;

layout (set = 0, binding = 1) uniform sampler2DArray texArray;
layout (set = 0, binding = 2) uniform sampler2DArray shadowMap;

struct AmbientLight// | base alignment = 16 + 16 + 16 = 64 | stride = 64
{
	vec4 direction;// direction | base alignment = 16 | offset = 0
	vec4 diffuse;// diffuse | base alignment = 16 | offset = 16
	vec4 specular;// specular | base alignment = 16 | offset = 32
	vec4 ambient;// ambient | base alignment = 16 | offset = 48
};

struct Material// | base alignment = 16 + 16 + 16 + 4 = 52 | stride = 64
{
	/* Ambient : RGB - Color; A - Texture Id */
	vec4 ambient;// ambient | base alignment = 16 | offset = 0
	vec4 diffuse;// diffuse | base alignment = 16 | offset = 16
	vec4 specular;// specular color | base alignment = 16 | offset = 32
	float shininess;// shininess | base alignment = 4 | offset = 48
};

layout (std140, set = 0, binding = 3) uniform UniformBufferObjFrag// | base alignment = 64 + 16 + 16 + 4 + 64 = 164 | stride = 176
{
	AmbientLight light;// base alignment = 64
	vec4 camPos;// base alignment = 16 | offset = 64
	vec4 skyColor;// base alignment = 16 | offset = 80
	vec4 splits;// base alignment = 4 | offset = 96
	mat4 casMVP[SHADOW_MAP_CASCADES];// base alignment = 64 | offset = 100
} ufrag;

layout (std430, set = 0, binding = 4) buffer MaterialStorage
{
	Material data[];
} materials;

layout (location = 0) in vec3 fragColor;// color of vertex
layout (location = 1) in vec3 fragUVW;// texture uvw
layout (location = 2) in vec3 fragNormal;// normal at position
layout (location = 3) in vec3 fragVert;// surface position
layout (location = 4) in vec3 fragView;
layout (location = 5) in float visibility;


layout (location = 0) out vec4 outPosition;
layout (location = 1) out vec4 outNormal;
layout (location = 2) out vec4 outAlbedo;

const mat4 biasMat = mat4( 
	0.5, 0.0, 0.0, 0.0,
	0.0, 0.5, 0.0, 0.0,
	0.0, 0.0, 1.0, 0.0,
	0.5, 0.5, 0.0, 1.0 
);

float textureProj(vec4 p, float casIndex, vec2 off)
{
	float shadow = 1.0F;
	float bias = 0.005F;
	vec4 sC = p / p.w;
	
	if (sC.z > -1.0 && sC.z < 1.0)
	{
		float d = texture(shadowMap, vec3(sC.st + off, casIndex)).r;
		if (sC.w > 0.0 && d < sC.z - bias)
			shadow = const_shadow;
	}
	
	return shadow;
}

float filterPCF(vec4 sc, float casIndex)
{
	ivec2 texDim = textureSize(shadowMap, 0).xy;
	float dx = const_scale / texDim.x;
	float dy = const_scale / texDim.y;
	
	float sF = 0.0F;
	int count = 0;
	int range = 1;
	
	for (int x = -range; x <= range; x++)
	{
		for (int y = -range; y <= range; y++)
		{
			sF += textureProj(sc, casIndex, vec2(dx * x, dy * y));
			count++;
		}
	}
	
	return sF / count;
}

void main()
{
	int index = int(fragUVW.z);
	vec4 color = texture(texArray, vec3(fragUVW.xy, materials.data[index]._texId));

	if (color.a < 0.5)
		discard;
	
	outPosition = vec4(fragVert.z, fragVert.y, fragVert.x, 1.0);

	vec3 N = normalize(fragNormal);

	// TODO: calc normal in tangent space
	outNormal = vec4(N.z, N.y, N.x, 1.0);
	
	//float attenu = 1.0F;
	//vec3 lightDir = normalize(ufrag.light.direction.xyz);
	
	//float DP = dot(N, lightDir);
	
	// Shadow Mapping
	/*
	uint casIndex = 0;
	for (uint i = 0; i < SHADOW_MAP_CASCADES - 1; ++i)
	{
		if (fragView.z < ufrag.splits[i])
			casIndex = i + 1;
	}
	
	vec4 shadowCoord = (biasMat * ufrag.casMVP[casIndex]) * vec4(fragVert, 1.0);
	float shadow = filterPCF(shadowCoord / shadowCoord.w, casIndex);
	*/
	//float shadow = 1.0;
	
	/* Diffuse */
	//vec3 texMatDiff = color.rgb + materials.data[index].diffuse.rgb;
	//vec3 diffuse = attenu * ufrag.light.diffuse.rgb * texMatDiff * max(0.0, DP) * shadow;
	
	/* Ambient */
	//vec3 ambient = ufrag.light.ambient.rgb * (materials.data[index].ambient.rgb + texMatDiff);
	
	/* Specular */
	//vec3 specular;
	
	//if (materials.data[index].shininess == 0.0F || DP < 0.0)
	//	specular = vec3(0.0, 0.0, 0.0);
	//else
	//{
	//	vec3 V = normalize(ufrag.camPos.xyz - fragVert);
	//	vec3 R = reflect(-lightDir, N);
	//	float coef = dot(R, V);
	//	
	//	specular = attenu * ufrag.light.specular.rgb * materials.data[index].specular.rgb * pow(max(0.0, coef), materials.data[index].shininess) * shadow;
	//}
	
	//vec3 lightColor = specular + diffuse + ambient;
	//vec3 finalColor = mix(ufrag.skyColor.rgb, lightColor, visibility);
	//outAlbedo = vec4(finalColor, color.a);

	outAlbedo = color;
}